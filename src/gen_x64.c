#include <gen_x64.h>
#include <reg.h>
#include <symbol.h>
#include <stdlib.h>
#include <sys/types.h>
#include <unistd.h>


FILE* g_outfile = NULL;
static cc_context* cc_ctx = NULL;

static void cc_prologue(void) {
  fputs(
      ";; Generated by the BetterC compiler.\n"
      ";; Copyright (c) 2022 Ian Marco Moffett, The Qnixx team\n"
      ";; Licensed under the BSD 3-Clause\n"
      ";; See LICENSE at https://git.mkall.org/svr/BetterC.git/tree\n\n"
      "bits 64\n\n",
  g_outfile);
}


static void cc_func_prologue(size_t glob_sym_id) {
  if (cc_ctx->func_is_global) fprintf(g_outfile, "global $%s\n", g_symtbl[glob_sym_id].name);
  fprintf(g_outfile, "$%s:\n"
                     "\tpush rbp\n"
                     "\tmov rbp, rsp\n", g_symtbl[glob_sym_id].name);
}


static void cc_return(reg_t r, uint8_t ret_val) {
  if (ret_val) fprintf(g_outfile, "\tmovzx rax, %s\n", g_bregs[r]);
  fputs("\tleave\n"
        "\tretq\n\n", g_outfile);
}


static void cc_func_epilogue(void) {
  if (!(cc_ctx->func_has_ret)) cc_return(-1, 0);
}


reg_t cc_x64_gen(astnode_t* node, reg_t reg, int parent_ast_top) {
  reg_t leftreg, rightreg;

  switch (node->op) {
    case A_FUNC:
      cc_func_prologue(node->left->id);

      if (node->right != NULL) {
        cc_x64_gen(node->right, -1, -1);
      }

      cc_func_epilogue();
      return -1;
    case A_RET:
      if (node->left == NULL) {
        cc_return(-1, 0);
      } else {
        reg_t r = cc_x64_gen(node->left, -1, -1);
        cc_return(r, 1);
      }
      return -1;
    case A_GLUE:
      cc_x64_gen(node->left, -1, node->op);
      freeall_regs();
      cc_x64_gen(node->right, -1, node->op);
      freeall_regs();
      return -1;
  }
  
  if (node->left) {
    leftreg = cc_x64_gen(node->left, -1, -1);
  }

  if (node->right) {
    rightreg = cc_x64_gen(node->right, -1, -1);
  }

  switch (node->op) {
    case A_ADD:
      return reg_add(leftreg, rightreg);
    case A_SUB:
      return reg_sub(leftreg, rightreg);
    case A_MUL:
      return reg_mul(leftreg, rightreg);
    case A_DIV:
      return reg_div(leftreg, rightreg);
    case A_INTLIT:
      return reg_load(node->val_int);
    default:
      printf("__INTERNAL_ERRROR__: Invalid AST operator %d\n", node->op);
      exit(1);
  }

  return -1;
}


void cc_gen_x64_init(cc_context* _cc_ctx) {
  cc_ctx = _cc_ctx;
  g_outfile = fopen("/tmp/bcc-out.asm", "w");
  cc_prologue();
}


void cc_gen_x64_elf(void) {
  fclose(g_outfile);
  g_outfile = NULL;

  system("nasm -felf64 /tmp/bcc-out.asm && ld /tmp/bcc-out.o /lib/bcc/crt0.o -o ./a.out");
  remove("/tmp/bcc-out.asm");
  remove("/tmp/bcc-obj-out.o");
}
